__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1646846694807, "lympha": [".py", "#!/usr/bin/python3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntry :\n from pyreact import Component,render,element\nexcept :\n pass\n \ntry :\n from org.transcrypt.stubs.browser import __pragma__\nexcept :\n pass\n \nimport sys\n\n\nimport subprocess\n\nimport os\n\nfrom ast import NodeVisitor\n\n\n\nimport re\n\n\nfrom math import sqrt\n\n\ndef preLexer():\n try :\n  document.body.style.backgroundColor='blue'\n  \n except :\n  pass\n try :\n  document.body.style.backgroundColor='#ff3333'\n  theItems=document.getElementsByClassName(\"theItems\").value\n except :\n  pass\n try :\n  for an_item in theItems:\n   addresses.append(an_item.value)\n   \n  urls=list()\n except :\n  pass\n try :\n  document.body.style.backgroundColor='#3f3'\n except :\n  pass\n try :\n  document.body.style.backgroundColor='#33f'\n  \n  for an_address in addresses:\n   urls.append(urllib.request.urlopen(an_address).read())\n except :\n  pass\n try :\n  document.body.style.backgroundColor='#ff3'\n  \n  for j in urls:\n   filetext=j\n   filetext=stripComments(str(filetext))\n   filetext=filetext.replace('\\n',' ')\n   filetext=filetext.replace('  ',' ')\n   series.extend(filetext.split(';'))\n except :\n  pass\n try :\n  document.body.style.backgroundColor='green'\n  \n  \n  modegraph=True\n  \n  modegraph=True\n  temporary_starts=list()\n  for a_step in document.select(\".stepNr\"):\n   steps=a_step.value\n  for start_item in document.select(\".theStarts\"):\n   starts.append(start_item.value)\n   temporary_starts.append(start_item.value)\n except :\n  pass\n  \n  \n  \ndef recursive_parse(node,substitutions):\n if hasattr(node.left,\"id\"):\n  if node.left.id in substitutions.keys():\n   node.left=substitutions[node.left.id]\n else :\n  recursive_parse(node.left,substitutions)\n  \n if hasattr(node.right,\"id\"):\n  if node.right.id in substitutions.keys():\n   node.right=substitutions[node.right.id]\n else :\n  recursive_parse(node.right,substitutions)\n  \n  \nCLI_filename=\"\"\nargv_len=len(sys.argv)\nfilenames=list()\nfilename=\"\"\n\n\nstarts=list()\n\n\nsteps=0\n\nlocal_files=True\n\n\nmode_graph=False\nmode_state=False\nmode_exe=False\nmode_show=False\nmode_map=False\n\n\nfilecheck=False\n\n\nexe_list=list()\nshow_list=list()\nmap_list=list()\nseries=list()\nsubstates=list()\nnextstates=list()\nspecs=list()\n\n\nglobal_relative_variable1=None\nglobal_relative_variable2=None\noperator1=None\nstatement_value=str()\n\nstatement_flow=0\n\n\nexe_objects=list()\n\nCLIcom_segment=0\n\n\n\n\nclass Evaluator(NodeVisitor):\n def __init__(self,**kwargs):\n  self._namespace=kwargs\n  \n def visit_Name(self,node):\n  return self._namespace[node.id]\n  \n def visit_Num(self,node):\n  return node.n\n  \n def visit_NameConstant(self,node):\n  return node.value\n  \n def visit_UnaryOp(self,node):\n  val=self.visit(node.operand)\n  return operators[type(node.op)](val)\n  \n def visit_BinOp(self,node):\n  lhs=self.visit(node.left)\n  rhs=self.visit(node.right)\n  return operators[type(node.op)](lhs,rhs)\n  \n def generic_visit(self,node):\n  raise ValueError(\"malformed node or string: \"+repr(node))\n  \n  \nclass Statement(dict):\n MARKER=object()\n \n def __init__(self,value=None ):\n  if value is None :\n   pass\n  elif isinstance(value,dict):\n   for key in value:\n    self.__setitem__(key,value[key])\n  else :\n   raise TypeError('expected dict')\n   \n def __setitem__(self,key,value):\n  if isinstance(value,dict)and not isinstance(value,Statement):\n   value=Statement(value)\n   \n  super(Statement,self).__setitem__(key,value)\n  \n  \n def __getitem__(self,key):\n  found=self.get(key,Statement.MARKER)\n  if found is Statement.MARKER:\n   found=Statement()\n   \n   super(Statement,self).__setitem__(key,found)\n   \n  return found\n  \n __setattr__,__getattr__=__setitem__,__getitem__\n \n \n \nobject_list=dict()\nobject_list=Statement(object_list)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef mapfunc():\n global CLI_filename\n global argv_len\n global filename\n global filenames\n \n \n global mode_graph\n global mode_state\n global filecheck\n global mode_exe\n global mode_show\n global mode_map\n global exe_list\n \n global map_list\n global series\n global substates\n global nextstates\n global specs\n \n global global_relative_variable2\n \n global statement_flow\n global statement_value\n global object_list\n global exe_objects\n \n global starts\n global show_list\n global steps\n \n if mode_graph ==True :\n  graphstr='digraph lympha {\\nnode [shape=record];'\n  \n for step in range(0,steps):\n  nextstates=list()\n  for start in starts:\n  \n   for key in range(0,len(object_list)):\n    endstring=str()\n    strr=str(\"%s\"%object_list[key].name)\n    strr=re.sub(\"\\s+\",\"\",strr.strip())\n    pre_statement_flow=1\n    if str(start)==strr:\n    \n     if object_list[key].datatype ==\"bina\":\n      pass\n      \n      \n     elif object_list[key].datatype ==\"bineval\"and len(object_list[key].binary_list)>=1:\n      pre_statement_flow=0\n      subfactors=list()\n      \n      for binobj in object_list[key].binary_list:\n       for item in range(0,len(object_list)):\n        thename=object_list[item].name\n        thename=str(thename)\n        \n        \n        \n        \n        if thename ==(\"%s\"%binobj.replace(\" \",\"\")):\n         subfactors.append(int(object_list[item].statement_flow))\n      sum1=subfactors.count(1)\n      sum0=subfactors.count(0)\n      if object_list[key].operator1 !=None :\n       if object_list[key].operator1 ==\"equiv\"and int(object_list[key].global_relative_variable1)==int(sum1):\n        pre_statement_flow=1\n        object_list[key].statement_value=(\"score: %s\\nthreshold: %s\"%(sum1,object_list[key].global_relative_variable1))\n       elif object_list[key].operator1 ==\"geq\"and int(object_list[key].global_relative_variable1)>=int(sum1):\n        pre_statement_flow=1\n        object_list[key].statement_value=(\"score: %s\\nthreshold: %s\"%(sum1,object_list[key].global_relative_variable1))\n       elif object_list[key].operator1 ==\"leq\"and int(object_list[key].global_relative_variable1)<=int(sum1):\n        pre_statement_flow=1\n        object_list[key].statement_value=(\"score: %s\\nthreshold: %s\"%(sum1,object_list[key].global_relative_variable1))\n       elif object_list[key].operator1 ==\"no\"and int(object_list[key].global_relative_variable1)!=int(sum1):\n        pre_statement_flow=1\n        object_list[key].statement_value=(\"score: %s\\nthreshold: %s\"%(sum1,object_list[key].global_relative_variable1))\n       elif object_list[key].operator1 ==\"g\"and int(object_list[key].global_relative_variable1)>int(sum1):\n        pre_statement_flow=1\n        object_list[key].statement_value=(\"score: %s\\nthreshold: %s\"%(sum1,object_list[key].global_relative_variable1))\n       elif object_list[key].operator1 ==\"l\"and int(object_list[key].global_relative_variable1)<int(sum1):\n        pre_statement_flow=1\n        object_list[key].statement_value=(\"score: %s\\nthreshold: %s\"%(sum1,object_list[key].global_relative_variable1))\n       else :\n        pre_statement_flow=0\n       print(object_list[key].statement_value)\n      object_list[key].statement_flow=int(pre_statement_flow)\n      \n      \n     if object_list[key].datatype ==\"nonbineval\":\n     \n     \n      endstring=str()\n      string=(object_list[key].statement_value.replace(\" \",\"\"))\n      pattern=re.compile(r'([\\=\\+\\-\\/\\*\\(\\)])')\n      iteratorUntouched=re.split(pattern,string)\n      \n      eqlist=list()\n      for varWord in iteratorUntouched:\n       print(varWord)\n       checked=0\n       for objWord in range(len(object_list)):\n        thename=object_list[objWord].name\n        if thename ==varWord:\n         eqlist.append(object_list[objWord].statement_value)\n         checked=1\n       if checked ==0:\n        eqlist.append(varWord)\n      endstring=((\"\").join(eqlist))\n      endstring=str(eval(str(endstring)))\n      object_list[key].statement_value=endstring\n      endnum=float()\n      endnum=float(eval(str(endstring)))\n      \n      pre_statement_flow=0\n      try :\n       if object_list[key].operator1 ==\"equiv\"and int(object_list[key].global_relative_variable1)==int(str(endnum)):\n        print(\"%s == %s ; exe\"%(int(object_list[key].global_relative_variable1),int(str(endnum))))\n        pre_statement_flow=1\n       elif object_list[key].operator1 ==\"leq\"and int(object_list[key].global_relative_variable1)>=int((endnum)):\n        print(\"%s >= %s ; exe\"%(int(object_list[key].global_relative_variable1),int(str(endnum))))\n        pre_statement_flow=1\n       elif object_list[key].operator1 ==\"geq\"and (int(object_list[key].global_relative_variable1)<=int(str(endnum))):\n        print(\"%s <= %s ; exe\"%(int(object_list[key].global_relative_variable1),int(str(endnum))))\n        pre_statement_flow=1\n       elif object_list[key].operator1 ==\"no\"and int(object_list[key].global_relative_variable1)!=int(str(endnum)):\n        print(\"%s != %s ; exe\"%(int(object_list[key].global_relative_variable1),int(str(endnum))))\n        pre_statement_flow=1\n       elif object_list[key].operator1 ==\"g\"and int(object_list[key].global_relative_variable1)<int(str(endnum)):\n        print(\"%s < %s ; exe\"%(int(object_list[key].global_relative_variable1),int(str(endnum))))\n        pre_statement_flow=1\n       elif object_list[key].operator1 ==\"l\"and int(object_list[key].global_relative_variable1)>int(str(endnum)):\n        print(\"%s > %s ; exe\"%(int(object_list[key].global_relative_variable1),int(str(endnum))))\n        pre_statement_flow=1\n       else :\n        pre_statement_flow=0\n        \n      except :\n       endnum=float(eval(str(endstring)))\n       \n       if object_list[key].operator1 ==\"equiv\"and float(object_list[key].global_relative_variable1)==float(str(endnum)):\n        print(\"%s == %s ; exe\"%(float(object_list[key].global_relative_variable1),float(str(endnum))))\n        pre_statement_flow=1\n       elif object_list[key].operator1 ==\"leq\"and float(object_list[key].global_relative_variable1)<=float((endnum)):\n        print(\"%s <= %s ; exe\"%(float(object_list[key].global_relative_variable1),float(str(endnum))))\n        pre_statement_flow=1\n       elif object_list[key].operator1 ==\"geq\"and (float(object_list[key].global_relative_variable1)>=float(str(endnum))):\n        print(\"%s >= %s ; exe\"%(float(object_list[key].global_relative_variable1),float(str(endnum))))\n        pre_statement_flow=1\n       elif object_list[key].operator1 ==\"no\"and float(object_list[key].global_relative_variable1)!=float(str(endnum)):\n        print(\"%s != %s ; exe\"%(float(object_list[key].global_relative_variable1),float(str(endnum))))\n        pre_statement_flow=1\n       elif object_list[key].operator1 ==\"g\"and float(object_list[key].global_relative_variable1)<float(str(endnum)):\n        print(\"%s < %s ; exe\"%(float(object_list[key].global_relative_variable1),float(str(endnum))))\n        pre_statement_flow=1\n       elif object_list[key].operator1 ==\"l\"and float(object_list[key].global_relative_variable1)>float(str(endnum)):\n        print(\"%s > %s ; exe\"%(float(object_list[key].global_relative_variable1),float(str(endnum))))\n        pre_statement_flow=1\n       else :\n        pre_statement_flow=0\n        \n      object_list[key].statement_flow=int(pre_statement_flow)\n      \n      \n     if object_list[key].datatype ==\"valu\":\n     \n     \n     \n      endstring=str()\n      string=(object_list[key].statement_value.replace(\" \",\"\"))\n      pattern=re.compile(r'([\\=\\+\\-\\/\\*\\(\\)])')\n      iteratorUntouched=re.split(pattern,string)\n      \n      eqlist=list()\n      for varWord in iteratorUntouched:\n       print(varWord)\n       checked=0\n       for objWord in range(len(object_list)):\n        thename=object_list[objWord].name\n        if thename ==varWord:\n         eqlist.append(object_list[objWord].statement_value)\n         checked=1\n       if checked ==0:\n        eqlist.append(varWord)\n      endstring=((\"\").join(eqlist))\n      endstring=str(eval(str(endstring)))\n      object_list[key].statement_value=endstring\n      \n     if object_list[key].flow ==0:\n      object_list[key].statement_flow=0\n      \n     if mode_exe ==True :\n      if object_list[key].statement_flow ==1:\n       try :\n        print('Executing %s.'%(start))\n        cmd=(\"./%s\"%start)\n        os.system(cmd)\n       except :\n        print('Failed to executing %s.'%(start))\n        \n     if mode_graph ==True :\n      if object_list[key].statement_flow ==0:\n       graph_string=\"\"\n       if object_list[key].datatype ==\"bina\":\n        graph_string=\"0B\"\n       if object_list[key].datatype ==\"bineval\":\n        graph_string=object_list[key].statement_value\n       if object_list[key].datatype ==\"nonbineval\":\n        graph_string=(\"score: %s\"%(object_list[key].statement_value))\n       if object_list[key].datatype ==\"valu\":\n        graph_string=object_list[key].statement_value\n       graphstr +=('\"%s\" [label=\"step %s: %s\\\\n%s\"] \\n'%(start,step+1,start,graph_string))\n      if object_list[key].statement_flow ==1:\n       graph_string=\"\"\n       if object_list[key].datatype ==\"bina\":\n        graph_string=\"1B\"\n       if object_list[key].datatype ==\"bineval\":\n        graph_string=object_list[key].statement_value\n       if object_list[key].datatype ==\"nonbineval\":\n        graph_string=(\"score: %s\"%(object_list[key].statement_value))\n       if object_list[key].datatype ==\"valu\":\n        graph_string=object_list[key].statement_value\n       graphstr +=('\"%s\" [label=\"step %s: %s\\\\n%s\", fillcolor=yellow, style=filled] \\n'%(start,step+1,start,str(graph_string)))\n     for next_object in object_list[key].next_list:\n      if mode_graph ==True :\n       if object_list[key].name !=next_object:\n        graphstr +=('\"%s\" -> \"%s\" \\n'%(start,next_object))\n      nextstates.append(next_object)\n      \n  nextstates=list()\n  \n  for start in starts:\n   for k in range(0,len(object_list)):\n    if object_list[k].name ==start:\n     for nexting in object_list[k].next_list:\n      for l in range(0,len(object_list)):\n       if object_list[l].name ==nexting:\n        nextstates.append(nexting)\n        if object_list[k].flow ==0 or object_list[k].statement_flow ==0:\n         object_list[l].flow=0\n         \n  del starts[:]\n  \n  for nexting in nextstates:\n   if nexting not in starts:\n    starts.append(nexting)\n  del nextstates[:]\n  \n if mode_graph ==True :\n  graphstr +='}'\n  open('lympha.dot','w').close()\n  outputfile=open(\"lympha.dot\",\"w\")\n  outputfile.write(graphstr)\n  outputfile.close()\n  cmd='dot lympha.dot -Tpdf -o lympha.pdf'\n  os.system(cmd)\n else :\n  try :\n   document.log.grphstr=graphstr\n  except :\n   pass\n   \n   \n   \n   \n   \n   \n   \n CLI_filename=None\n argv_len=None\n filename=None\n filenames=None\n starts=None\n steps=None\n mode_graph=None\n mode_state=None\n filecheck=None\n mode_exe=None\n mode_show=None\n mode_map=None\n exe_list=None\n show_list=None\n map_list=None\n series=None\n substates=None\n nextstates=None\n specs=None\n global_relative_variable1=None\n global_relative_variable2=None\n operator1=None\n statement_flow=None\n statement_value=None\n object_list=None\n exe_objects=None\n \n del CLI_filename,argv_len,filename,filenames,starts,steps,mode_graph,mode_state,filecheck,mode_exe,mode_show,mode_map,exe_list,show_list,map_list,substates,nextstates,specs,global_relative_variable1,global_relative_variable2,operator1,statement_flow,statement_value,exe_objects,object_list,\n \ndef statefunc():\n global object_list\n for key,obj in object_list.items():\n  print(\"%s\"%object_list[key].name)\n  \ndef stripComments(code):\n code=str(code)\n return re.sub(r'(?m)^ *#.*\\n?','',code)\n \ndef lexer():\n global CLIcom_segment\n series\n global filenames\n global local_files\n \n if local_files ==True :\n  for afilename in filenames:\n   textfile=open(filename,'r')\n   filetext=textfile.read()\n   filetext=stripComments(filetext)\n   filetext=filetext.replace('\\n',' ')\n   filetext=filetext.replace('  ',' ')\n   series.extend(filetext.split(';'))\n   \n global object_list\n \n nexts=list()\n conts=list()\n \n for serie in series:\n  prearrowobjs=serie.split('->')\n  arrowobjs=list()\n  for anobj in prearrowobjs:\n   almostdone=anobj.split('=')\n   arrowobjs.append(almostdone[0])\n  count=0\n  oops=str()\n  nexts=list()\n  conts=list()\n  specs=list()\n  flow=int()\n  global_relative_variable1=float()\n  operator1=str()\n  statement_flow=int()\n  statement_value=str()\n  scale=list()\n  \n  \n  pre_count=0\n  count_objs=int()\n  for anobj in arrowobjs:\n   anobj=re.sub(\"\\s*\",\"\",anobj)\n   eqobjs=re.compile(r\"((<=)|(>=)|(!=)|(==)(<)|(>))\").split(anobj)\n   taken=0\n   \n   for takenkey in range(0,len(object_list)):\n    if object_list[takenkey].name ==anobj:\n     taken=1\n     \n     \n    else :\n    \n     pre_count +=1\n   count_objs=pre_count\n   \n   \n   if (anobj)!=\"\"and taken ==0:\n    object_list[((count_objs))].name=str(anobj)\n    object_list[((count_objs))].next_list=list()\n    object_list[((count_objs))].binary_list=list()\n    object_list[((count_objs))].operation=str(\"\")\n    object_list[((count_objs))].flow=1\n    object_list[((count_objs))].statement_flow=1\n    object_list[((count_objs))].statement_value=str()\n    object_list[((count_objs))].global_relative_variable1=float()\n    object_list[((count_objs))].datatype=\"\"\n    \n    \n for serie in series:\n  arrowobj=serie.split('->')\n  count=0\n  nexts=list()\n  conts=list()\n  \n  for i in range(0,len(arrowobj)):\n   for key in range(0,len(object_list)):\n    thename=str(object_list[key].name)\n    thename=re.sub(\"\\s*\",\"\",thename)\n    if i !=0:\n     if thename ==arrowobj[(0)].replace(\" \",\"\"):\n      nexting=\"\"\n      nexting=arrowobj[i].replace(\" \",\"\")\n      if not nexting ==\"\":\n       object_list[key].next_list.append(nexting)\n      print(object_list[key].next_list)\n      print(object_list[key].name)\n      \n      \n      \n      \n      \n for serie in series:\n  count=0\n  anobj=serie\n  \n  \n  if anobj !=\"\"and \" = \"in anobj:\n  \n  \n   sides=anobj.split(' = ')\n   side1=sides[0]\n   side2=sides[1]\n   side1=side1.replace(\" \",\"\")\n   side2=side2.replace(\" \",\"\")\n   for key in range(0,len(object_list)):\n    thename=object_list[key].name\n    if (\"%s\"%thename)==sides[0].replace(\" \",\"\"):\n    \n    \n     if str(\"1B\")in str(sides[1]):\n     \n      object_list[key].statement_flow=1\n      object_list[key].datatype=\"bina\"\n     elif str(\"0B\")in str(sides[1]):\n     \n      object_list[key].statement_flow=0\n      object_list[key].datatype=\"bina\"\n      \n      \n      \n      \n     elif (\"==\"in sides[1]or \"!=\"in sides[1]or \"<=\"in sides[1]or \">=\"in sides[1]or \"<\"in sides[1]or \">\"in sides[1])and not \"->\"in sides[1]:\n     \n     \n     \n      if \"==\"in (sides[1]):\n       object_list[key].operator1=\"equiv\"\n       \n      if \">=\"in (sides[1]):\n       object_list[key].operator1=\"geq\"\n       \n      if \"<=\"in (sides[1]):\n       object_list[key].operator1=\"leq\"\n       \n      if \"!=\"in (sides[1]):\n       object_list[key].operator1=\"no\"\n      if re.compile(\".*>.*\").match(sides[1])and not re.compile(r\"(>=)\").match(sides[1]):\n       object_list[key].operator1=\"g\"\n      if re.compile(\".*<.*\").match(sides[1])and not re.compile(r\"(<=)\").match(sides[1]):\n       object_list[key].operator1=\"l\"\n      print(object_list[key].operator1)\n      preop=sides[1].replace(\" \",\"\")\n      bin_chopped=0\n      if \"\\|{\"in preop or \"|{\"in preop:\n      \n       bin_chopped=1\n      preop=re.sub(r'(\\|{)',' ',preop)\n      preop=re.sub(r'(}\\|)',' ',preop)\n      \n      \n      chopcompile=re.compile(r\"(<=|>=|!=|==|<|>)\")\n      operator_chop=re.split(chopcompile,preop)\n      print(operator_chop)\n      \n      zerochop=operator_chop[0].replace(\" \",\"\")\n      object_list[key].global_relative_variable1=zerochop\n      \n      if bin_chopped ==1:\n       binary_sums=list(operator_chop[2].split(','))\n       for binary in binary_sums:\n        binary=binary.replace(\" \",\"\")\n        if binary !=\"\":\n         binary=str(binary.replace(\" \",\"\"))\n         object_list[key].binary_list.append(str(binary))\n        object_list[key].datatype=\"bineval\"\n        \n      elif bin_chopped ==0:\n       object_list[key].statement_value=operator_chop[2]\n       object_list[key].datatype=\"nonbineval\"\n       \n       \n     elif sides[0]!=\"\"and sides[1]!=\"\":\n      print(\"YYY %s\"%object_list[key].name)\n      \n      object_list[key].statement_value=sides[1]\n      object_list[key].datatype=\"valu\"\n      \n    print(\"DATA TYPE: %s\"%object_list[key].datatype)\n    \n    \n    \n    \n    \n    \n    \n if mode_graph ==True or mode_exe ==True :\n  mapfunc()\n  \n  \n  \n  \nif __name__ =='__main__':\n for x in range(0,argv_len):\n  if sys.argv[x]==\"-f\":\n   CLI_filename=sys.argv[x+1]\n   filename=CLI_filename\n   filenames.append(filename)\n   filecheck=True\n  if sys.argv[x]==\"-h\":\n   print('-h for help\\n-f file\\n-graph\\n-start \"start node\"\\n-steps amount of steps')\n  if sys.argv[x]==\"-exe\":\n   mode_exe=True\n  if sys.argv[x]==\"-graph\":\n   mode_graph=True\n  if sys.argv[x]==\"-statements\":\n   mode_state=True\n  if sys.argv[x]==\"-steps\":\n   steps=int(sys.argv[x+1])\n  if sys.argv[x]==\"-start\":\n   starts.append(sys.argv[x+1])\n   \n if filecheck ==True :\n  lexer()\n else :\n  print(\"Please add file names.\")\n", ["ast", "math", "org.transcrypt.stubs.browser", "os", "pyreact", "re", "subprocess", "sys"]], "node_modules.transcrypt-loader.index": [".py", "path=require('path')\nchild_process=require('child_process')\nloader_utils=require(\"loader-utils\");\n\n\n\n\n\nDEFAULT_PACKAGE_CONFIG={\n\"command\":\"python3 -m transcrypt\",\n\"arguments\":[\n\n\n\n\n\"--nomin\",\n\n\"--map\",\n\n\"--verbose\"\n]\n}\n\n\n\n\n\ndef main(src):\n\n config={}\n config.update(DEFAULT_PACKAGE_CONFIG)\n config.update(loader_utils.getOptions(this))\n \n \n fileinfo=path.parse(this.resource)\n relative_dir=path.relative(this.rootContext,fileinfo.dir)\n if fileinfo.js_name =='__init__':\n  py_module=relative_dir.split(path.sep).join('.')\n else :\n  py_module=path.join(relative_dir,fileinfo.js_name).split(path.sep).join('.')\n target_path=path.join(this.rootContext,'__target__',py_module)+'.js'\n import_path='./'+path.relative(fileinfo.dir,target_path)\n runinfo_path=path.join(this.rootContext,'__target__',relative_dir,fileinfo.js_name)+'.transcrypt.json'\n \n \n cmd=[]\n cmd.append(config['command'])\n cmd.extend(config['arguments'])\n cmd.append('\"{}\"'.format(py_module.replace('\"','\\\\\"')))\n cmd_options={\n \n \n \n 'cwd':this.rootContext,\n 'encoding':'utf8',\n }\n try :\n  stdout=str(child_process.execSync(' '.join(cmd),cmd_options))\n except object as err:\n  console.log('Error compiling {}: {}'.format(this.resource,err.stdout))\n  raise\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n return 'export * from \"{}\";'.format(import_path)\n \n \n \n \n \nmodule.exports=main\n", []], "node_modules.transcrypt-loader.__target__.index": [".py", "path=require('path')\nchild_process=require('child_process')\nloader_utils=require(\"loader-utils\");\n\n\n\n\n\nDEFAULT_PACKAGE_CONFIG={\n\"command\":\"python3 -m transcrypt\",\n\"arguments\":[\n\n\n\n\n\"--nomin\",\n\n\"--map\",\n\n\"--verbose\"\n]\n}\n\n\n\n\n\ndef main(src):\n\n config={}\n config.update(DEFAULT_PACKAGE_CONFIG)\n config.update(loader_utils.getOptions(this))\n \n \n fileinfo=path.parse(this.resource)\n relative_dir=path.relative(this.rootContext,fileinfo.dir)\n if fileinfo.js_name =='__init__':\n  py_module=relative_dir.split(path.sep).join('.')\n else :\n  py_module=path.join(relative_dir,fileinfo.js_name).split(path.sep).join('.')\n target_path=path.join(this.rootContext,'__target__',py_module)+'.js'\n import_path='./'+path.relative(fileinfo.dir,target_path)\n runinfo_path=path.join(this.rootContext,'__target__',relative_dir,fileinfo.js_name)+'.transcrypt.json'\n \n \n cmd=[]\n cmd.append(config['command'])\n cmd.extend(config['arguments'])\n cmd.append('\"{}\"'.format(py_module.replace('\"','\\\\\"')))\n cmd_options={\n \n \n \n 'cwd':this.rootContext,\n 'encoding':'utf8',\n }\n try :\n  stdout=str(child_process.execSync(' '.join(cmd),cmd_options))\n except object as err:\n  console.log('Error compiling {}: {}'.format(this.resource,err.stdout))\n  raise\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n return 'export * from \"{}\";'.format(import_path)\n \n \n \n \n \nmodule.exports=main\n", []], "node_modules.transcrypt-loader.__target__.org.transcrypt.__runtime__": [".py", "\n\n\n\n\n\n\ncopy=Math=__typeof__=__repr__=document=console=window=0\n\n\n\n\n\n\nclass BaseException:\n pass\n \nclass Exception(BaseException):\n\n def __init__(self,*args,**kwargs):\n  self.__args__=args\n  try :\n   self.stack=kwargs.error.stack\n  except :\n   self.stack='No stack trace available'\n   \n   \n def __repr__(self):\n  if len(self.__args__)>1:\n   return '{}{}'.format(self.__class__.__name__,repr(tuple(self.__args__)))\n  elif len(self.__args__):\n   return '{}({})'.format(self.__class__.__name__,repr(self.__args__[0]))\n  else :\n   return '{}()'.format(self.__class__.__name__)\n   \n def __str__(self):\n  if len(self.__args__)>1:\n   return str(tuple(self.__args__))\n  elif len(self.__args__):\n   return str(self.__args__[0])\n  else :\n   return ''\n   \nclass IterableError(Exception):\n def __init__(self,error):\n  Exception.__init__(self,'Can\\'t iterate over non-iterable',error=error)\n  \nclass StopIteration(Exception):\n def __init__(self,error):\n  Exception.__init__(self,'Iterator exhausted',error=error)\n  \nclass ValueError(Exception):\n def __init__(self,message,error):\n  Exception.__init__(self,message,error=error)\n  \nclass KeyError(Exception):\n def __init__(self,message,error):\n  Exception.__init__(self,message,error=error)\n  \nclass AssertionError(Exception):\n def __init__(self,message,error):\n  if message:\n   Exception.__init__(self,message,error=error)\n  else :\n   Exception.__init__(self,error=error)\n   \nclass NotImplementedError(Exception):\n def __init__(self,message,error):\n  Exception.__init__(self,message,error=error)\n  \nclass IndexError(Exception):\n def __init__(self,message,error):\n  Exception.__init__(self,message,error=error)\n  \nclass AttributeError(Exception):\n def __init__(self,message,error):\n  Exception.__init__(self,message,error=error)\n  \nclass TypeError(Exception):\n def __init__(self,message,error):\n  Exception.__init__(self,message,error=error)\n  \n  \n  \n  \n  \nclass Warning(Exception):\n ''\n \n pass\n \nclass UserWarning(Warning):\n pass\n \nclass DeprecationWarning(Warning):\n pass\n \nclass RuntimeWarning(Warning):\n pass\n \n \n \ndef __sort__(iterable,key=None ,reverse=False ):\n if key:\n  iterable.sort(lambda a,b:1 if key(a)>key(b)else -1)\n else :\n  iterable.sort()\n  \n if reverse:\n  iterable.reverse()\n  \ndef sorted(iterable,key=None ,reverse=False ):\n if type(iterable)==dict:\n  result=copy(iterable.keys())\n else :\n  result=copy(iterable)\n  \n __sort__(result,key,reverse)\n return result\n \n \n \ndef map(func,iterable):\n return [func(item)for item in iterable]\n \n \ndef filter(func,iterable):\n if func ==None :\n  func=bool\n return [item for item in iterable if func(item)]\n \ndef divmod(n,d):\n return n //d,n %d\n \n \n \nclass complex:\n def __init__(self,real,imag=None ):\n  if imag ==None :\n   if type(real)==complex:\n    self.real=real.real\n    self.imag=real.imag\n   else :\n    self.real=real\n    self.imag=0\n  else :\n   self.real=real\n   self.imag=imag\n   \n def __neg__(self):\n  return complex(-self.real,-self.imag)\n  \n def __exp__(self):\n  modulus=Math.exp(self.real)\n  return complex(modulus *Math.cos(self.imag),modulus *Math.sin(self.imag))\n  \n def __log__(self):\n  return complex(Math.log(Math.sqrt(self.real *self.real+self.imag *self.imag)),Math.atan2(self.imag,self.real))\n  \n def __pow__(self,other):\n  return (self.__log__().__mul__(other)).__exp__()\n  \n def __rpow__(self,real):\n  return self.__mul__(Math.log(real)).__exp__()\n  \n def __mul__(self,other):\n  if __typeof__(other)is 'number':\n   return complex(self.real *other,self.imag *other)\n  else :\n   return complex(self.real *other.real -self.imag *other.imag,self.real *other.imag+self.imag *other.real)\n   \n def __rmul__(self,real):\n  return complex(self.real *real,self.imag *real)\n  \n def __div__(self,other):\n  if __typeof__(other)is 'number':\n   return complex(self.real /other,self.imag /other)\n  else :\n   denom=other.real *other.real+other.imag *other.imag\n   return complex(\n   (self.real *other.real+self.imag *other.imag)/denom,\n   (self.imag *other.real -self.real *other.imag)/denom\n   )\n   \n def __rdiv__(self,real):\n  denom=self.real *self.real\n  return complex(\n  (real *self.real)/denom,\n  (real *self.imag)/denom\n  )\n  \n def __add__(self,other):\n  if __typeof__(other)is 'number':\n   return complex(self.real+other,self.imag)\n  else :\n   return complex(self.real+other.real,self.imag+other.imag)\n   \n def __radd__(self,real):\n  return complex(self.real+real,self.imag)\n  \n def __sub__(self,other):\n  if __typeof__(other)is 'number':\n   return complex(self.real -other,self.imag)\n  else :\n   return complex(self.real -other.real,self.imag -other.imag)\n   \n def __rsub__(self,real):\n  return complex(real -self.real,-self.imag)\n  \n def __repr__(self):\n  return '({}{}{}j)'.format(self.real,'+'if self.imag >=0 else '',self.imag)\n  \n def __str__(self):\n  return __repr__(self)[1:-1]\n  \n def __eq__(self,other):\n  if __typeof__(other)is 'number':\n   return self.real ==other\n  else :\n   return self.real ==other.real and self.imag ==other.imag\n   \n def __ne__(self,other):\n  if __typeof__(other)is 'number':\n   return self.real !=other\n  else :\n   return self.real !=other.real or self.imag !=other.imag\n   \n def conjugate(self):\n  return complex(self.real,-self.imag)\n  \ndef __conj__(aNumber):\n if isinstance(aNumber,complex):\n  return complex(aNumber.real,-aNumber.imag)\n else :\n  return complex(aNumber,0)\n  \n  \n  \nclass __Terminal__:\n ''\n\n\n\n\n\n\n \n \n def __init__(self):\n  self.buffer=''\n  \n  try :\n   self.element=document.getElementById('__terminal__')\n  except :\n   self.element=None\n   \n  if self.element:\n   self.element.style.overflowX='auto'\n   self.element.style.boxSizing='border-box'\n   self.element.style.padding='5px'\n   self.element.innerHTML='_'\n   \n   \n   \n def print(self,*args,sep=' ',end='\\n'):\n  self.buffer='{}{}{}'.format(self.buffer,sep.join([str(arg)for arg in args]),end)[-4096:]\n  \n  if self.element:\n   self.element.innerHTML=self.buffer.replace('\\n','<br>').replace(' ','&nbsp')\n   self.element.scrollTop=self.element.scrollHeight\n  else :\n   console.log(sep.join([str(arg)for arg in args]))\n   \n def input(self,question):\n  self.print('{}'.format(question),end='')\n  answer=window.prompt('\\n'.join(self.buffer.split('\\n')[-8:]))\n  self.print(answer)\n  return answer\n  \n  \n  \n__terminal__=__Terminal__()\n\nprint=__terminal__.print\ninput=__terminal__.input\n", []]}
__BRYTHON__.update_VFS(scripts)
